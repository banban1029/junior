% 遅延微分方程式のシミュレーション

% 行列の定義
%{
A0 = [-2,1,0,0,0,0;
       1,-2,0,0,0,0;
       0,0,-2,0,0,0;
       0,1,0,-3,0,0;
       0,0,0,0,-2,0;
       0,0,0,0,0,-1];

A1 = [0,0,0,0,0,0;
     0,0,0,1,0,0;
     1,0,0,0,0,0;
     0,0,0,0,1,0;
     0,0,0,0,0,1;
     0,0,0,0,1,0];

A2 = [0,0,0,0,0,0;
    0,0,0,0,0,0;
    0,0,0,0,0,0;
    0,0,1,0,0,0;
    0,0,0,1,0,0;
    0,0,0,0,0,0];

A3 = [0,0,1,0,0,0;
    0,0,0,0,0,0;
    0,0,0,1,0,0;
    0,0,0,0,0,0;
    0,0,0,0,0,0;
    0,0,0,0,0,0];
%}

%{
A0 = [-1,1,0,0,0,0;
       1,-2,0,0,0,0;
       0,0,0,0,0,0;
       0,1,0,-1,0,0;
       0,0,0,0,-1,0;
       0,0,0,0,0,-1];

A1 = [0,0,0,0,0,0;
     0,0,0,1,0,0;
     1,0,-1,0,0,0;
     0,0,0,-2,1,0;
     0,0,0,0,0,1;
     0,0,0,0,1,0];

A2 = [-1,0,0,0,0,0;
    0,0,0,0,0,0;
    0,0,-1,0,0,0;
    0,0,1,0,0,0;
    0,0,0,1,-1,0;
    0,0,0,0,0,0];

A3 = [0,0,1,0,0,0;
    0,0,0,0,0,0;
    0,0,0,1,0,0;
    0,0,0,0,0,0;
    0,0,0,0,0,0;
    0,0,0,0,0,0];
%}

A0 = [-1,1,0,0,0,0;
       1,-2,0,1,0,0;
       0,0,0,0,0,0;
       0,0,0,-1,0,0;
       0,0,0,0,-1,0;
       0,0,0,0,0,-1];

A1 = [0,0,1,0,0,0;
     0,0,0,0,0,0;
     0,0,-1,0,0,0;
     0,1,0,-2,0,0;
     0,0,0,1,0,1;
     0,0,0,0,1,0];

A2 = [-1,0,0,0,0,0;
    0,0,0,0,0,0;
    0,0,-1,1,0,0;
    0,0,0,0,1,0;
    0,0,0,0,-1,0;
    0,0,0,0,0,0];

A3 = [0,0,0,0,0,0;
    0,0,0,0,0,0;
    1,0,0,0,0,0;
    0,0,1,0,0,0;
    0,0,0,0,0,0;
    0,0,0,0,0,0];


% 遅延時間の定義
h1 = 0.3;  % 遅延時間1
h2 = 0.6;  % 遅延時間2
h3 = 0.9;

% 合成行列 (14), (15) で使用
Ak_sum = A0 + A1 + A2 + A3;
Ak_hsum = (eye(size(Ak_sum)) + h1 * A1 + h2 * A2 + h3 * A3);

% 左固有ベクトル u0 の計算
[~, D, V] = eig(Ak_sum.'); % 転置して左固有ベクトルを計算
eig_zero_idx = find(abs(diag(D)) < 1e-6); % 固有値が 0 に近いものを探す
u0 = V(:, eig_zero_idx); % 左固有ベクトル u0
u0 = u0 / norm(u0);      % 正規化

% 右固有ベクトル v0 の計算
[~, D, V] = eig(Ak_sum); % 右固有ベクトルを計算
v0 = V(:, eig_zero_idx); % 固有値 0 に対応する右固有ベクトル
v0 = v0 / (u0' * (eye(size(Ak_sum)) + h1*A1 + h2*A2 + h3*A3) * v0); % 正規化

% 収束値 xf の計算
x0 = [10;0;5;8;4;9]; % 初期状態
xf = v0 * u0' * Ak_hsum * x0;

disp('収束値 xf:');
disp(xf);


% 時間の範囲と刻み幅
tspan = [0 25];  % シミュレーション時間
dt = 0.01;       % 時間刻み

% 初期条件

hist = @(t) x0;    % 過去の状態を一定値として初期化

% 遅延微分方程式を解く
dde_func = @(t, x, Z) A0*x + A1*Z(:,1) + A2*Z(:,2) + A3*Z(:,3); % 遅延の定義
lags = [h1,h2,h3]; % 遅延を指定
sol = dde23(dde_func, lags, hist, tspan); % 遅延微分方程式の解

% 結果をプロット
figure;
plot(sol.x, sol.y);
title('収束の様子');
xlabel('時間 t');
ylabel('状態 x(t)');
legend('x_1(t)', 'x_2(t)', 'x_3(t)', 'x_4(t)', 'x_5(t)', 'x_6(t)');
grid on;
